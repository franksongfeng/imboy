
# 消息结构体
```
Msg = {"id":ID, "status":Status, "type":Type, "from":From, "to":To, "payload": Payload, "server_ts": ServerTs}

Msg2 = {"type": "error", "code":Code, "payload": Payload, "server_ts": Ts}
```


## Msg2.error
* Msg2.code = 1 无需弹窗错误，可以记录日志后直接忽略错误 Msg2.payload 可能为空，不需要处理
* Msg2.code = 2 带title弹窗，Msg2.payload 不能为空 必须包含title content字段
* Msg2.code = 3 无title弹窗，Msg2.payload 不能为空 必须包含 content字段
* Msg2.code = 705 token无效、刷新token
* Msg2.code = 706 token无效 (包含缺失token情况) 或者设备ID不存在 需要重新登录

# Msg.id
Xid().toString()


# Msg.Type

## 单聊（c2c[any()]）
* Msg.Type = <<"c2c">>

## 群聊(c2g[any()])

## 推送(S2C)
* Payload.msg_type = logged_another_device 在其他设备登录了, Payload.content = ""
* Payload.msg_type = online 用户在线状态变更, data['from'] 为好友ID
* Payload.msg_type = offline 用户在线状态变更, data['from'] 为好友ID
* Payload.msg_type = hide 用户在线状态变更, data['from'] 为好友ID
* Payload.msg_type = apply_friend 添加好友申请, Payload.content = ""
* Payload.msg_type = apply_friend_confirm 添加好友申请确认, Payload.content = ""

apply_friend
```
{"from":{"source":"qrcode","msg":"我是 nick leeyi👍🏻👍🏻就","remark":"leeyi101","role":"all","donotlookhim":false,"donotlethimlook":true},"to":{},"msg_type":"custom","custom_type":"apply_friend"}
```

## 客户端确认消息 CLIENT_ACK
```
% 客户端确认消息
websocket_handle({text, <<"CLIENT_ACK", Tail/binary>>}, State) ->
    [Type, MsgId, DID] = binary:split(Tail, <<",">>, [global]),
    ?LOG(["CLIENT_ACK", Tail]),
    CurrentUid = proplists:get_value(current_uid, State),
    case Type of
        <<"C2C">> ->
            websocket_logic:c2c_client_ack(MsgId, CurrentUid, DID),
            {ok, State, hibernate};
        <<"S2C">> ->
            websocket_logic:s2c_client_ack(MsgId, CurrentUid, DID),
            {ok, State, hibernate}
    end;
```

# ServerTs
服务器的当前毫秒时间戳
```
 Ts = util_dt:milliseconds(),
```
